use convert_case::Casing;
use glob::glob;
use serde::Deserialize;
use std::{
    fs::File,
    io::{Read, Write},
    path::{Path, PathBuf},
};

macro_rules! p {
    ($($tokens: tt)*) => {
        println!("cargo:warning={}", format!($($tokens)*))
    }
}

#[derive(Debug, Deserialize)]
struct Protocol {
    #[serde(rename = "$value", default)]
    pub elements: Vec<Element>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "lowercase")]
enum Element {
    Enum(Enum),
    Struct(Struct),
    Packet(Packet),
}

#[derive(Debug, Deserialize)]
struct Enum {
    #[serde(rename = "@name")]
    pub name: String,
    #[serde(rename = "@type")]
    pub data_type: String,
    #[serde(rename = "$value", default)]
    pub elements: Vec<EnumElement>,
}

#[derive(Debug, Deserialize)]
enum EnumElement {
    #[serde(rename = "comment")]
    Comment(String),
    #[serde(rename = "value")]
    Value(EnumValue),
}

#[derive(Debug, Deserialize)]
struct EnumValue {
    #[serde(rename = "@name")]
    pub name: String,
    #[serde(rename = "comment")]
    pub comment: Option<String>,
    #[serde(rename = "$text")]
    pub value: i32,
}

#[derive(Debug, Deserialize)]
struct Struct {
    #[serde(rename = "@name")]
    pub name: String,
    #[serde(rename = "$value", default)]
    pub elements: Vec<StructElement>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "lowercase")]
enum StructElement {
    Break,
    Chunked(Chunked),
    Comment(String),
    Dummy(Dummy),
    Field(Field),
    Array(Array),
    Length(Length),
    Switch(Switch),
}

#[derive(Debug, Deserialize)]
struct Chunked {
    #[serde(rename = "$value", default)]
    pub elements: Vec<StructElement>,
}

#[derive(Debug, Deserialize)]
struct Field {
    #[serde(rename = "@name")]
    pub name: Option<String>,
    #[serde(rename = "@type")]
    pub data_type: String,
    #[serde(rename = "$value", default)]
    pub value: Option<String>,
    pub comment: Option<String>,
    #[serde(rename = "padded")]
    pub padded: Option<bool>,
    #[serde(rename = "optional")]
    pub length: Option<String>,
}

fn default_as_true() -> bool {
    true
}

#[derive(Debug, Deserialize)]
struct Array {
    #[serde(rename = "@name")]
    pub name: String,
    #[serde(rename = "@type")]
    pub data_type: String,
    #[serde(rename = "@length")]
    pub length: Option<String>,
    #[serde(rename = "optional")]
    pub optional: Option<bool>,
    #[serde(rename = "delimited")]
    pub delimited: Option<bool>,
    #[serde(rename = "@trailing-delimiter")]
    #[serde(default = "default_as_true")]
    pub trailing_delimiter: bool,
    pub comment: Option<String>,
}

#[derive(Debug, Deserialize)]
struct Length {
    #[serde(rename = "@name")]
    pub name: String,
    #[serde(rename = "@type")]
    pub data_type: String,
    #[serde(rename = "@length")]
    pub optional: Option<bool>,
    #[serde(rename = "@offset")]
    pub offset: Option<i32>,
}

#[derive(Debug, Deserialize)]
struct Dummy {
    #[serde(rename = "@type")]
    pub data_type: String,
    #[serde(rename = "$value", default)]
    pub value: String,
}

#[derive(Debug, Deserialize)]
struct Switch {
    #[serde(rename = "@field")]
    pub field: String,
    #[serde(rename = "$value", default)]
    pub cases: Vec<Case>,
}

#[derive(Debug, Deserialize)]
#[serde(rename = "case")]
struct Case {
    #[serde(rename = "@default")]
    pub default: Option<bool>,
    #[serde(rename = "@value")]
    pub value: Option<String>,
    #[serde(rename = "$value", default)]
    pub elements: Option<Vec<StructElement>>,
}

#[derive(Debug, Deserialize)]
struct Packet {
    #[serde(rename = "@action")]
    pub action: String,
    #[serde(rename = "@family")]
    pub family: String,
    #[serde(rename = "$value", default)]
    pub elements: Vec<StructElement>,
}

static CODEGEN_WARNING: &str = r"// This file is automatically generated by build.rs
// Please do not edit it directly

";

static RUST_KEYWORDS: [&str; 52] = [
    "abstract", "alignof", "as", "become", "box", "break", "const", "continue", "crate", "do",
    "else", "enum", "extern", "false", "final", "fn", "for", "if", "impl", "in", "let", "loop",
    "macro", "match", "mod", "move", "mut", "offsetof", "override", "priv", "proc", "pub", "pure",
    "ref", "return", "Self", "self", "sizeof", "static", "struct", "super", "trait", "true",
    "type", "typeof", "unsafe", "unsized", "use", "virtual", "where", "while", "yield",
];

fn main() {
    println!("cargo:rerun-if-changed=eo-protocol/xml");

    let mut protocols = Vec::new();
    // find all protocol.xml files in the xml directory recursively
    for entry in glob("eo-protocol/xml/**/protocol.xml").expect("Failed to read glob pattern") {
        match entry {
            Ok(path) => match parse_protocol_file(&path) {
                Ok(protocol) => protocols.push((protocol, path.to_owned())),
                Err(e) => {
                    panic!(
                        "Failed to parse protocol file: {}. {}",
                        e,
                        path.to_string_lossy()
                    );
                }
            },
            Err(e) => {
                panic!("Failed to read protocol file: {}", e);
            }
        }
    }

    // clear the protocol directory
    if Path::new("src/protocol").exists() {
        std::fs::remove_dir_all("src/protocol").unwrap();
    }

    for (protocol, path) in &protocols {
        let output_dir = get_output_directory(path);
        std::fs::create_dir_all(&output_dir).unwrap();

        let mut mod_code = String::new();
        mod_code.push_str(CODEGEN_WARNING);

        for element in &protocol.elements {
            match element {
                Element::Enum(protocol_enum) => {
                    generate_enum_file(protocol_enum, &output_dir, &mut mod_code).unwrap()
                }
                _ => {} // TODO
            }
        }

        let is_root = path.parent().unwrap() == Path::new("eo-protocol/xml");
        if is_root {
            // TODO: don't hard code this
            mod_code.push_str("pub mod map;\n");
            mod_code.push_str("pub mod net;\n");
            mod_code.push_str("pub mod r#pub;\n");
        }

        let is_net = path.parent().unwrap() == Path::new("eo-protocol/xml/net");
        if is_net {
            // TODO: don't hard code this
            mod_code.push_str("pub mod client;\n");
            mod_code.push_str("pub mod server;\n");
        }

        let mut mod_file = File::create(output_dir.join("mod.rs")).unwrap();
        mod_file.write_all(mod_code.as_bytes()).unwrap();
    }
}

fn generate_enum_file(
    protocol_enum: &Enum,
    path: &PathBuf,
    mod_code: &mut String,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut code = String::new();
    code.push_str(CODEGEN_WARNING);

    let comments = match protocol_enum
        .elements
        .iter()
        .find(|e| matches!(e, EnumElement::Comment(_)))
    {
        Some(EnumElement::Comment(comment)) => get_comments(comment),
        _ => vec![],
    };

    append_doc_comments(&mut code, comments);
    code.push_str(&format!("#[derive(Debug, PartialEq, Eq)]\n"));
    code.push_str(&format!("pub enum {} {{\n", protocol_enum.name));

    let variants: Vec<&EnumValue> = protocol_enum
        .elements
        .iter()
        .filter_map(|e| match e {
            EnumElement::Value(value) => Some(value),
            _ => None,
        })
        .collect();

    for variant in &variants {
        let comments = match &variant.comment {
            Some(comment) => get_comments(comment),
            None => vec![],
        };

        append_doc_comments(&mut code, comments);
        code.push_str(&format!("    {},\n", replace_keyword(&variant.name)));
    }
    code.push_str("}\n\n");

    code.push_str(&format!("impl {} {{\n", protocol_enum.name));
    code.push_str(&format!(
        "    pub fn from_i32(value: i32) -> Option<Self> {{\n"
    ));
    code.push_str(&format!("        match value {{\n"));

    for variant in &variants {
        code.push_str(&format!(
            "            {} => Some(Self::{}),\n",
            variant.value,
            replace_keyword(&variant.name)
        ));
    }

    code.push_str(&format!("            _ => None,\n"));
    code.push_str(&format!("        }}\n"));
    code.push_str(&format!("    }}\n\n"));
    code.push_str(&format!("    pub fn to_i32(&self) -> i32 {{\n"));
    code.push_str(&format!("        match self {{\n"));

    for variant in &variants {
        code.push_str(&format!(
            "            Self::{} => {},\n",
            replace_keyword(&variant.name),
            variant.value
        ));
    }

    code.push_str(&format!("        }}\n"));
    code.push_str(&format!("    }}\n"));
    code.push_str(&format!("}}\n\n"));

    code.push_str(CODEGEN_WARNING);

    let snake_name = protocol_enum.name.to_case(convert_case::Case::Snake);
    mod_code.push_str(&format!("mod {};\n", snake_name));
    mod_code.push_str(&format!("pub use {}::*;\n", snake_name));

    let mut file = File::create(path.join(format!(
        "{}.rs",
        protocol_enum.name.to_case(convert_case::Case::Snake)
    )))?;
    file.write_all(code.as_bytes())?;
    Ok(())
}

fn get_comments(comment: &str) -> Vec<&str> {
    comment.split('\n').map(|c| c.trim()).collect::<Vec<&str>>()
}

fn append_doc_comments(code: &mut String, comments: Vec<&str>) {
    for comment in &comments {
        code.push_str(&format!("/// {}\n", comment));
    }
}

fn get_output_directory(base: &Path) -> PathBuf {
    Path::new("src/protocol").join(
        base.parent()
            .unwrap()
            .strip_prefix("eo-protocol/xml")
            .unwrap(),
    )
}

fn replace_keyword(word: &str) -> String {
    if word == "Self" {
        return "SELF".to_owned();
    }

    if RUST_KEYWORDS.contains(&word) {
        format!("r#{}", word)
    } else {
        word.to_owned()
    }
}

fn parse_protocol_file(path: &std::path::Path) -> Result<Protocol, Box<dyn std::error::Error>> {
    let mut file = File::open(path)?;
    let mut xml = String::new();
    file.read_to_string(&mut xml)?;
    let protocol: Protocol = quick_xml::de::from_str(&xml)?;
    Ok(protocol)
}
