use convert_case::Casing;
use glob::glob;
use serde::Deserialize;
use std::{
    collections::HashSet,
    fs::File,
    io::{Read, Write},
    path::{Path, PathBuf},
};

macro_rules! p {
    ($($tokens: tt)*) => {
        println!("cargo:warning={}", format!($($tokens)*))
    }
}

#[derive(Debug, Deserialize)]
struct Protocol {
    #[serde(rename = "$value", default)]
    pub elements: Vec<Element>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "lowercase")]
enum Element {
    Enum(Enum),
    Struct(Struct),
    Packet(Packet),
}

#[derive(Debug, Deserialize, Clone)]
struct Enum {
    #[serde(rename = "@name")]
    pub name: String,
    #[serde(rename = "@type")]
    pub data_type: String,
    #[serde(rename = "$value", default)]
    pub elements: Vec<EnumElement>,
}

#[derive(Debug, Deserialize, Clone)]
enum EnumElement {
    #[serde(rename = "comment")]
    Comment(String),
    #[serde(rename = "value")]
    Value(EnumValue),
}

#[derive(Debug, Deserialize, Clone)]
struct EnumValue {
    #[serde(rename = "@name")]
    pub name: String,
    #[serde(rename = "comment")]
    pub comment: Option<String>,
    #[serde(rename = "$text")]
    pub value: i32,
}

#[derive(Debug, Deserialize, Clone)]
struct Struct {
    #[serde(rename = "@name")]
    pub name: String,
    #[serde(rename = "$value", default)]
    pub elements: Vec<StructElement>,
}

#[derive(Debug, Deserialize, Clone)]
#[serde(rename_all = "lowercase")]
enum StructElement {
    Break,
    Chunked(Chunked),
    Comment(String),
    Dummy(Dummy),
    Field(Field),
    Array(Array),
    Length(Length),
    Switch(Switch),
}

#[derive(Debug, Deserialize, Clone)]
struct Chunked {
    #[serde(rename = "$value", default)]
    pub elements: Vec<StructElement>,
}

#[derive(Debug, Deserialize, Clone)]
struct Field {
    #[serde(rename = "@name")]
    pub name: Option<String>,
    #[serde(rename = "@type")]
    pub data_type: String,
    #[serde(rename = "$value", default)]
    pub value: Option<String>,
    pub comment: Option<String>,
    #[serde(rename = "@padded")]
    pub padded: Option<bool>,
    #[serde(rename = "@optional")]
    pub optional: Option<bool>,
    #[serde(rename = "@length")]
    pub length: Option<String>,
}

fn default_as_true() -> bool {
    true
}

#[derive(Debug, Deserialize, Clone)]
struct Array {
    #[serde(rename = "@name")]
    pub name: String,
    #[serde(rename = "@type")]
    pub data_type: String,
    #[serde(rename = "@length")]
    pub length: Option<String>,
    #[serde(rename = "@optional")]
    pub optional: Option<bool>,
    #[serde(rename = "@delimited")]
    pub delimited: Option<bool>,
    #[serde(rename = "@trailing-delimiter")]
    #[serde(default = "default_as_true")]
    pub trailing_delimiter: bool,
    pub comment: Option<String>,
}

#[derive(Debug, Deserialize, Clone)]
struct Length {
    #[serde(rename = "@name")]
    pub name: String,
    #[serde(rename = "@type")]
    pub data_type: String,
    #[serde(rename = "@length")]
    pub optional: Option<bool>,
    #[serde(rename = "@offset")]
    pub offset: Option<i32>,
}

#[derive(Debug, Deserialize, Clone)]
struct Dummy {
    #[serde(rename = "@type")]
    pub data_type: String,
    #[serde(rename = "$value", default)]
    pub value: String,
}

#[derive(Debug, Deserialize, Clone)]
struct Switch {
    #[serde(rename = "@field")]
    pub field: String,
    #[serde(rename = "$value", default)]
    pub cases: Vec<Case>,
}

#[derive(Debug, Deserialize, Clone)]
#[serde(rename = "case")]
struct Case {
    #[serde(rename = "@default")]
    pub default: Option<bool>,
    #[serde(rename = "@value")]
    pub value: Option<String>,
    #[serde(rename = "$value", default)]
    pub elements: Option<Vec<StructElement>>,
}

#[derive(Debug, Deserialize, Clone)]
struct Packet {
    #[serde(rename = "@action")]
    pub action: String,
    #[serde(rename = "@family")]
    pub family: String,
    #[serde(rename = "$value", default)]
    pub elements: Vec<StructElement>,
}

static CODEGEN_WARNING: &str = r"// This file is automatically generated by build.rs
// Please do not edit it directly

";

static RUST_KEYWORDS: [&str; 52] = [
    "abstract", "alignof", "as", "become", "box", "break", "const", "continue", "crate", "do",
    "else", "enum", "extern", "false", "final", "fn", "for", "if", "impl", "in", "let", "loop",
    "macro", "match", "mod", "move", "mut", "offsetof", "override", "priv", "proc", "pub", "pure",
    "ref", "return", "Self", "self", "sizeof", "static", "struct", "super", "trait", "true",
    "type", "typeof", "unsafe", "unsized", "use", "virtual", "where", "while", "yield",
];

fn main() {
    println!("cargo:rerun-if-changed=eo-protocol/xml");

    let mut protocols = Vec::new();
    // find all protocol.xml files in the xml directory recursively
    for entry in glob("eo-protocol/xml/**/protocol.xml").expect("Failed to read glob pattern") {
        match entry {
            Ok(path) => match parse_protocol_file(&path) {
                Ok(protocol) => protocols.push((protocol, path.to_owned())),
                Err(e) => {
                    panic!(
                        "Failed to parse protocol file: {}. {}",
                        e,
                        path.to_string_lossy()
                    );
                }
            },
            Err(e) => {
                panic!("Failed to read protocol file: {}", e);
            }
        }
    }

    // clear the protocol directory
    if Path::new("src/protocol").exists() {
        std::fs::remove_dir_all("src/protocol").unwrap();
    }

    let enums: Vec<Enum> = protocols
        .iter()
        .map(|(protocol, _)| {
            protocol.elements.iter().filter_map(|e| match e {
                Element::Enum(protocol_enum) => Some(protocol_enum.clone()),
                _ => None,
            })
        })
        .flatten()
        .collect();

    let structs: Vec<Struct> = protocols
        .iter()
        .map(|(protocol, _)| {
            protocol.elements.iter().filter_map(|e| match e {
                Element::Struct(protocol_struct) => Some(protocol_struct.clone()),
                _ => None,
            })
        })
        .flatten()
        .collect();

    for (protocol, path) in &protocols {
        let output_dir = get_output_directory(path);
        std::fs::create_dir_all(&output_dir).unwrap();

        let mut mod_code = String::new();
        mod_code.push_str(CODEGEN_WARNING);

        for element in &protocol.elements {
            match element {
                Element::Enum(protocol_enum) => {
                    generate_enum_file(protocol_enum, &output_dir, &mut mod_code).unwrap()
                }
                Element::Struct(protocol_struct) => {
                    let imports = get_imports(&protocol_struct.elements, &protocols);
                    generate_struct_file(
                        protocol_struct,
                        imports,
                        &output_dir,
                        &mut mod_code,
                        &enums,
                        &structs,
                    )
                    .unwrap();
                }
                Element::Packet(packet) => {
                    let imports = get_imports(&packet.elements, &protocols);
                    generate_packet_file(
                        packet,
                        imports,
                        &output_dir,
                        &mut mod_code,
                        &enums,
                        &structs,
                    )
                    .unwrap();
                }
            }
        }

        let is_root = path.parent().unwrap() == Path::new("eo-protocol/xml");
        if is_root {
            // TODO: don't hard code this
            mod_code.push_str("pub mod map;\n");
            mod_code.push_str("pub mod net;\n");
            mod_code.push_str("pub mod r#pub;\n");
        }

        let is_net = path.parent().unwrap() == Path::new("eo-protocol/xml/net");
        if is_net {
            // TODO: don't hard code this
            mod_code.push_str("pub mod client;\n");
            mod_code.push_str("pub mod server;\n");
        }

        let mut mod_file = File::create(output_dir.join("mod.rs")).unwrap();
        mod_file.write_all(mod_code.as_bytes()).unwrap();
    }
}

fn generate_enum_file(
    protocol_enum: &Enum,
    path: &PathBuf,
    mod_code: &mut String,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut code = String::new();
    code.push_str(CODEGEN_WARNING);

    let comments = match protocol_enum
        .elements
        .iter()
        .find(|e| matches!(e, EnumElement::Comment(_)))
    {
        Some(EnumElement::Comment(comment)) => get_comments(comment),
        _ => vec![],
    };

    append_doc_comments(&mut code, comments);
    code.push_str(&format!("#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n"));
    code.push_str(&format!("pub enum {} {{\n", protocol_enum.name));

    let variants: Vec<&EnumValue> = protocol_enum
        .elements
        .iter()
        .filter_map(|e| match e {
            EnumElement::Value(value) => Some(value),
            _ => None,
        })
        .collect();

    for variant in &variants {
        let comments = match &variant.comment {
            Some(comment) => get_comments(comment),
            None => vec![],
        };

        append_doc_comments(&mut code, comments);
        code.push_str(&format!("    {},\n", replace_keyword(&variant.name)));
    }
    code.push_str("}\n\n");

    code.push_str(&format!(
        "impl TryFrom<{}> for {} {{\n",
        get_field_type(&protocol_enum.data_type),
        protocol_enum.name
    ));
    code.push_str(&format!("    type Error = String;\n"));
    code.push_str(&format!(
        "    fn try_from(value: {}) -> Result<Self, <{} as TryFrom<{}>>::Error> {{\n",
        get_field_type(&protocol_enum.data_type),
        protocol_enum.name,
        get_field_type(&protocol_enum.data_type)
    ));
    code.push_str(&format!("        match value {{\n"));

    for variant in &variants {
        code.push_str(&format!(
            "            {} => Ok(Self::{}),\n",
            variant.value,
            replace_keyword(&variant.name)
        ));
    }

    code.push_str(&format!(
        "            _ => Err(format!(\"Invalid value for {}: {{}}\", value)),\n",
        protocol_enum.name
    ));
    code.push_str(&format!("        }}\n"));
    code.push_str(&format!("    }}\n"));
    code.push_str(&format!("}}\n\n"));

    code.push_str(&format!(
        "impl From<{}> for {} {{\n",
        protocol_enum.name,
        get_field_type(&protocol_enum.data_type)
    ));
    code.push_str(&format!(
        "    fn from(value: {}) -> Self {{\n",
        protocol_enum.name
    ));
    code.push_str(&format!("        match value {{\n"));
    for variant in &variants {
        code.push_str(&format!(
            "            {}::{} => {},\n",
            protocol_enum.name,
            replace_keyword(&variant.name),
            variant.value
        ));
    }
    code.push_str(&format!("        }}\n"));
    code.push_str(&format!("    }}\n"));
    code.push_str(&format!("}}\n\n"));

    code.push_str(&format!("impl Default for {} {{\n", protocol_enum.name));

    code.push_str(&format!("    fn default() -> Self {{\n"));
    code.push_str(&format!(
        "        Self::{}\n",
        replace_keyword(&variants[0].name)
    ));
    code.push_str(&format!("    }}\n"));
    code.push_str(&format!("}}\n"));

    code.push_str(CODEGEN_WARNING);

    let snake_name = protocol_enum.name.to_case(convert_case::Case::Snake);
    mod_code.push_str(&format!("mod {};\n", snake_name));
    mod_code.push_str(&format!("pub use {}::*;\n", snake_name));

    let mut file = File::create(path.join(format!(
        "{}.rs",
        protocol_enum.name.to_case(convert_case::Case::Snake)
    )))?;
    file.write_all(code.as_bytes())?;
    Ok(())
}

fn generate_struct_file(
    protocol_struct: &Struct,
    imports: Vec<String>,
    path: &PathBuf,
    mod_code: &mut String,
    enums: &[Enum],
    structs: &[Struct],
) -> Result<(), Box<dyn std::error::Error>> {
    let mut code = String::new();
    code.push_str(CODEGEN_WARNING);

    for import in &imports {
        code.push_str(&format!("{}\n", import));
    }

    if imports.len() > 0 {
        code.push_str("\n");
    }

    write_struct(
        &protocol_struct.name,
        &protocol_struct.elements,
        &mut code,
        enums,
        structs,
    );

    for switch in protocol_struct.elements.iter().filter_map(|e| match e {
        StructElement::Switch(switch) => Some(switch),
        _ => None,
    }) {
        let name = get_field_type(&format!("{}_{}_data", protocol_struct.name, switch.field));
        generate_switch_code(&name, &mut code, switch, enums, structs);
    }

    code.push_str(CODEGEN_WARNING);

    let snake_name = protocol_struct.name.to_case(convert_case::Case::Snake);
    let mut file = File::create(path.join(format!("{}.rs", snake_name)))?;

    file.write_all(code.as_bytes())?;

    mod_code.push_str(&format!("mod {};\n", snake_name));
    mod_code.push_str(&format!("pub use {}::*;\n", snake_name));

    Ok(())
}

fn generate_packet_file(
    packet: &Packet,
    imports: Vec<String>,
    path: &PathBuf,
    mod_code: &mut String,
    enums: &[Enum],
    structs: &[Struct],
) -> Result<(), Box<dyn std::error::Error>> {
    let mut code = String::new();
    code.push_str(CODEGEN_WARNING);

    for import in &imports {
        code.push_str(&format!("{}\n", import));
    }

    if imports.len() > 0 {
        code.push_str("\n");
    }

    // either Server or Client
    let source = match path.to_str().unwrap() {
        "src/protocol/net/server" => "Server",
        "src/protocol/net/client" => "Client",
        _ => panic!("Unknown protocol path: {}", path.to_string_lossy()),
    };

    let name = format!("{}{}{}Packet", packet.family, packet.action, source);

    write_struct(&name, &packet.elements, &mut code, enums, structs);

    for switch in packet.elements.iter().filter_map(|e| match e {
        StructElement::Switch(switch) => Some(switch),
        _ => None,
    }) {
        let name = get_field_type(&format!("{}_{}_data", name, switch.field));
        generate_switch_code(&name, &mut code, switch, enums, structs);
    }

    // Assumes no nested chunked elements
    for chunked in packet.elements.iter().filter_map(|e| match e {
        StructElement::Chunked(chunked) => Some(chunked),
        _ => None,
    }) {
        for switch in chunked.elements.iter().filter_map(|e| match e {
            StructElement::Switch(switch) => Some(switch),
            _ => None,
        }) {
            let name = get_field_type(&format!("{}_{}_data", name, switch.field));
            generate_switch_code(&name, &mut code, switch, enums, structs);
        }
    }

    code.push_str(CODEGEN_WARNING);

    let snake_name = name.to_case(convert_case::Case::Snake);
    let mut file = File::create(path.join(format!("{}.rs", snake_name)))?;

    file.write_all(code.as_bytes())?;

    mod_code.push_str(&format!("mod {};\n", snake_name));
    mod_code.push_str(&format!("pub use {}::*;\n", snake_name));

    Ok(())
}

fn generate_switch_code(
    name: &str,
    code: &mut String,
    switch: &Switch,
    enums: &[Enum],
    structs: &[Struct],
) {
    code.push_str(&format!("#[derive(Debug, PartialEq, Eq)]\n"));
    code.push_str(&format!("pub enum {} {{\n", name));
    for case in switch.cases.iter().filter(|c| c.elements.is_some()) {
        match case.default {
            Some(true) => {
                code.push_str(&format!(
                    "    Default({}),\n",
                    get_field_type(&format!("{}_default", name)),
                ));
            }
            _ => {
                code.push_str(&format!(
                    "    {}({}),\n",
                    replace_keyword(&case.value.as_ref().unwrap()),
                    get_field_type(&format!("{}_{}", name, case.value.as_ref().unwrap()))
                ));
            }
        }
    }
    code.push_str("}\n\n");

    for case in switch.cases.iter().filter(|c| c.elements.is_some()) {
        let elements = case.elements.as_ref().unwrap();
        let name = match case.default {
            Some(true) => get_field_type(&format!("{}_default", name)),
            _ => get_field_type(&format!("{}_{}", name, case.value.as_ref().unwrap())),
        };

        write_struct(&name, elements, code, enums, structs);

        for switch in elements.iter().filter_map(|e| match e {
            StructElement::Switch(switch) => Some(switch),
            _ => None,
        }) {
            let name = get_field_type(&format!("{}_{}_data", name, switch.field));
            generate_switch_code(&name, code, switch, enums, structs);
        }
    }
}

fn write_struct(
    name: &str,
    elements: &[StructElement],
    code: &mut String,
    enums: &[Enum],
    structs: &[Struct],
) {
    let comments = match elements
        .iter()
        .find(|e| matches!(e, StructElement::Comment(_)))
    {
        Some(StructElement::Comment(comment)) => get_comments(comment),
        _ => vec![],
    };

    for comment in &comments {
        code.push_str(&format!("/// {}\n", comment));
    }

    let mut derives = vec!["Debug", "Default", "PartialEq", "Eq"];
    if name == "Coords" {
        derives.push("Clone");
        derives.push("Copy");
    }

    code.push_str(&format!("#[derive({})]\n", derives.join(", ")));
    code.push_str(&format!("pub struct {} {{\n", name));
    write_struct_fields(code, name, elements);
    code.push_str("}\n\n");

    code.push_str(&format!("impl {} {{\n", name));
    code.push_str("    pub fn new() -> Self {\n");
    code.push_str("        Self::default()\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");

    code.push_str(&format!("impl EoSerialize for {} {{\n", name));
    code.push_str(&format!(
        "    /// Serializes a [{}] into the given [EoWriter] instance\n",
        name
    ));
    code.push_str(
        "    fn serialize(&self, writer: &mut EoWriter) -> Result<(), EoSerializeError> {\n",
    );
    for element in elements {
        match element {
            StructElement::Break => {
                generate_serialize_break(code);
            }
            StructElement::Dummy(dummy) => {
                generate_serialize_dummy(code, dummy);
            }
            StructElement::Field(field) => {
                generate_serialize_field(code, field, enums, structs);
            }
            StructElement::Array(array) => generate_serialize_array(code, array, enums, structs),
            StructElement::Length(length) => generate_serialize_length(code, length),
            StructElement::Switch(switch) => {
                let field = match elements.iter().find(|e| match e {
                    StructElement::Field(field) => field.name == Some(switch.field.clone()),
                    StructElement::Chunked(chunked) => chunked.elements.iter().any(|e| match e {
                        StructElement::Field(field) => field.name == Some(switch.field.clone()),
                        _ => false,
                    }),
                    _ => false,
                }) {
                    Some(StructElement::Field(field)) => field,
                    Some(StructElement::Chunked(chunked)) => {
                        match chunked.elements.iter().find(|e| match e {
                            StructElement::Field(field) => field.name == Some(switch.field.clone()),
                            _ => false,
                        }) {
                            Some(StructElement::Field(field)) => field,
                            _ => panic!("Switch field not found! {}", name),
                        }
                    }
                    _ => panic!("Switch field not found! {}", name),
                };

                let switch_enum = enums
                    .iter()
                    .find(|e| e.name == field.data_type)
                    .expect("Switch enum not found!");
                generate_serialize_switch(code, name, switch, switch_enum);
            }
            StructElement::Chunked(chunked) => {
                for element in &chunked.elements {
                    match element {
                        StructElement::Break => {
                            generate_serialize_break(code);
                        }
                        StructElement::Dummy(dummy) => {
                            generate_serialize_dummy(code, dummy);
                        }
                        StructElement::Field(field) => {
                            generate_serialize_field(code, field, enums, structs);
                        }
                        StructElement::Array(array) => {
                            generate_serialize_array(code, array, enums, structs)
                        }
                        StructElement::Length(length) => generate_serialize_length(code, length),
                        StructElement::Switch(switch) => {
                            let field = match elements.iter().find(|e| match e {
                                StructElement::Field(field) => {
                                    field.name == Some(switch.field.clone())
                                }
                                StructElement::Chunked(chunked) => {
                                    chunked.elements.iter().any(|e| match e {
                                        StructElement::Field(field) => {
                                            field.name == Some(switch.field.clone())
                                        }
                                        _ => false,
                                    })
                                }
                                _ => false,
                            }) {
                                Some(StructElement::Field(field)) => field,
                                Some(StructElement::Chunked(chunked)) => {
                                    match chunked.elements.iter().find(|e| match e {
                                        StructElement::Field(field) => {
                                            field.name == Some(switch.field.clone())
                                        }
                                        _ => false,
                                    }) {
                                        Some(StructElement::Field(field)) => field,
                                        _ => panic!("Switch field not found! {}", name),
                                    }
                                }
                                _ => panic!("Switch field not found! {}", name),
                            };

                            let switch_enum = enums
                                .iter()
                                .find(|e| e.name == field.data_type)
                                .expect("Switch enum not found!");
                            generate_serialize_switch(code, name, switch, switch_enum);
                        }
                        _ => {}
                    }
                }
            }
            _ => {}
        }
    }
    code.push_str("        Ok(())\n");
    code.push_str("    }\n");
    code.push_str(&format!(
        "    /// Deserializes a [{}] from an [EoReader] instance\n",
        name
    ));
    code.push_str("    fn deserialize(reader: &EoReader) -> Result<Self, EoReaderError> {\n");
    code.push_str(
        "        let current_chunked_readming_mode = reader.get_chunked_reading_mode();\n",
    );
    code.push_str("        let mut data = Self::default();\n");

    for element in elements {
        match element {
            StructElement::Chunked(chunked) => {
                code.push_str("        reader.set_chunked_reading_mode(true);\n");
                for element in &chunked.elements {
                    match element {
                        StructElement::Break => {
                            code.push_str("        reader.next_chunk()?;\n");
                        }
                        StructElement::Chunked(_) => {
                            panic!("Nested chunked elements are not supported! {}", name);
                        }
                        StructElement::Length(length) => {
                            generate_deserialize_length(code, length);
                        }
                        StructElement::Dummy(dummy) => {
                            code.push_str(&format!("        reader.get_{}()?;\n", dummy.data_type));
                        }
                        StructElement::Field(field) => {
                            generate_deserialize_field(code, field, enums, structs)
                        }
                        StructElement::Array(array) => {
                            generate_deserialize_array(code, array, enums, structs)
                        }
                        StructElement::Switch(switch) => {
                            let field = match elements.iter().find(|e| match e {
                                StructElement::Field(field) => {
                                    field.name == Some(switch.field.clone())
                                }
                                StructElement::Chunked(chunked) => {
                                    chunked.elements.iter().any(|e| match e {
                                        StructElement::Field(field) => {
                                            field.name == Some(switch.field.clone())
                                        }
                                        _ => false,
                                    })
                                }
                                _ => false,
                            }) {
                                Some(StructElement::Field(field)) => field,
                                Some(StructElement::Chunked(chunked)) => {
                                    match chunked.elements.iter().find(|e| match e {
                                        StructElement::Field(field) => {
                                            field.name == Some(switch.field.clone())
                                        }
                                        _ => false,
                                    }) {
                                        Some(StructElement::Field(field)) => field,
                                        _ => panic!("Switch field not found! {}", name),
                                    }
                                }
                                _ => panic!("Switch field not found! {}", name),
                            };

                            let switch_enum = enums
                                .iter()
                                .find(|e| e.name == field.data_type)
                                .expect("Switch enum not found!");
                            generate_deserialize_switch(code, name, switch, switch_enum);
                        }
                        _ => {}
                    }
                }
            }
            StructElement::Dummy(dummy) => {
                code.push_str(&format!("        reader.get_{}()?;\n", dummy.data_type));
            }
            StructElement::Length(length) => {
                generate_deserialize_length(code, length);
            }
            StructElement::Field(field) => generate_deserialize_field(code, field, enums, structs),
            StructElement::Array(array) => generate_deserialize_array(code, array, enums, structs),
            StructElement::Switch(switch) => {
                let field = match elements.iter().find(|e| match e {
                    StructElement::Field(field) => field.name == Some(switch.field.clone()),
                    StructElement::Chunked(chunked) => chunked.elements.iter().any(|e| match e {
                        StructElement::Field(field) => field.name == Some(switch.field.clone()),
                        _ => false,
                    }),
                    _ => false,
                }) {
                    Some(StructElement::Field(field)) => field,
                    Some(StructElement::Chunked(chunked)) => {
                        match chunked.elements.iter().find(|e| match e {
                            StructElement::Field(field) => field.name == Some(switch.field.clone()),
                            _ => false,
                        }) {
                            Some(StructElement::Field(field)) => field,
                            _ => panic!("Switch field not found! {}", name),
                        }
                    }
                    _ => panic!("Switch field not found! {}", name),
                };

                let switch_enum = enums
                    .iter()
                    .find(|e| e.name == field.data_type)
                    .expect("Switch enum not found!");
                generate_deserialize_switch(code, name, switch, switch_enum);
            }
            _ => {}
        }
    }
    code.push_str("        reader.set_chunked_reading_mode(current_chunked_readming_mode);\n");
    code.push_str("        Ok(data)\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");
}

fn needs_result(data_type: &str) -> bool {
    match data_type {
        "byte" | "string" | "encoded_string" => false,
        _ => true,
    }
}

fn generate_serialize_break(code: &mut String) {
    code.push_str("        writer.add_byte(0xff);\n");
}

fn generate_serialize_dummy(code: &mut String, dummy: &Dummy) {
    code.push_str(&format!(
        "        writer.add_{}({}){};\n",
        dummy.data_type,
        if dummy.value.chars().all(|c| c.is_numeric()) {
            dummy.value.to_owned()
        } else {
            format!("\"{}\"", dummy.value)
        },
        if needs_result(&dummy.data_type) {
            "?"
        } else {
            ""
        }
    ));
}

fn generate_serialize_field(code: &mut String, field: &Field, enums: &[Enum], structs: &[Struct]) {
    let optional = match field.optional {
        Some(true) => true,
        _ => false,
    };

    if optional {
        let name = match field.name {
            Some(ref name) => name,
            None => panic!("Field name is required for optional fields!"),
        };

        code.push_str(&format!(
            "        if let Some({}) = self.{} {{\n",
            replace_keyword(&name),
            replace_keyword(&name)
        ));
        generate_inner_field_serialize(code, field, enums, structs);
        code.push_str("        }\n");
    } else {
        generate_inner_field_serialize(code, field, enums, structs);
    }
}

fn generate_inner_field_serialize(
    code: &mut String,
    field: &Field,
    enums: &[Enum],
    structs: &[Struct],
) {
    let (data_type, enum_data_type) = if field.data_type.contains(":") {
        field.data_type.split_once(":").unwrap()
    } else {
        (field.data_type.as_str(), "")
    };

    let optional = match field.optional {
        Some(true) => true,
        _ => false,
    };

    if let Some(ref protocol_enum) = enums.iter().find(|e| e.name == data_type) {
        // for the Foobar:short shit
        let enum_data_type = if enum_data_type.is_empty() {
            protocol_enum.data_type.to_string()
        } else {
            enum_data_type.to_string()
        };

        let name = if let Some(value) = &field.value {
            format!("{}::{}", get_field_type(&data_type), value)
        } else {
            let name = field.name.as_ref().unwrap();
            if optional {
                replace_keyword(&name)
            } else {
                format!("self.{}", replace_keyword(&name))
            }
        };

        code.push_str(&format!(
            "writer.add_{}({}.into()){};\n",
            enum_data_type,
            name,
            if needs_result(&enum_data_type) {
                "?"
            } else {
                ""
            }
        ));
    } else if let Some(_) = structs.iter().find(|s| s.name == data_type) {
        let name = if let Some(value) = &field.value {
            value.to_owned()
        } else {
            let name = field.name.as_ref().unwrap();
            if optional {
                replace_keyword(&name)
            } else {
                format!("self.{}", name)
            }
        };
        code.push_str(&format!("{}.serialize(writer)?;\n", name))
    } else {
        match data_type {
            "blob" => code.push_str(&format!(
                "writer.add_bytes(&self.{});\n",
                field.name.as_ref().unwrap()
            )),
            "bool" => {
                let name = if let Some(value) = &field.value {
                    value.to_owned()
                } else {
                    let name = field.name.as_ref().unwrap();
                    if optional {
                        replace_keyword(&name)
                    } else {
                        format!("self.{}", name)
                    }
                };
                code.push_str(&format!(
                    "writer.add_{}(if {} {{ 1 }} else {{ 0 }}){};\n",
                    if enum_data_type.is_empty() {
                        "char"
                    } else {
                        enum_data_type
                    },
                    name,
                    if needs_result(if enum_data_type.is_empty() {
                        "char"
                    } else {
                        enum_data_type
                    }) {
                        "?"
                    } else {
                        ""
                    }
                ))
            }
            _ => {
                let name = if let Some(value) = &field.value {
                    if value.chars().all(|c| c.is_numeric()) {
                        value.to_owned()
                    } else {
                        format!("\"{}\"", value)
                    }
                } else {
                    let name = field.name.as_ref().unwrap();
                    if optional {
                        replace_keyword(&name)
                    } else {
                        format!("self.{}", name)
                    }
                };

                code.push_str(&format!(
                    "writer.add_{}({}{}){};\n",
                    replace_keyword(&field.data_type),
                    if matches!(field.data_type.as_str(), "string" | "encoded_string") {
                        "&"
                    } else {
                        ""
                    },
                    name,
                    if needs_result(&field.data_type) {
                        "?"
                    } else {
                        ""
                    }
                ));
            }
        }
    }
}

fn generate_serialize_array(code: &mut String, array: &Array, enums: &[Enum], structs: &[Struct]) {}

fn generate_serialize_length(code: &mut String, length: &Length) {}

fn generate_serialize_switch(
    code: &mut String,
    struct_name: &str,
    switch: &Switch,
    switch_enum: &Enum,
) {
}

fn generate_deserialize_length(code: &mut String, length: &Length) {
    let optional = match length.optional {
        Some(true) => true,
        _ => false,
    };

    if optional {
        code.push_str("if reader.remaining()? > 0 {{\n");
    }

    code.push_str(&format!(
        "        let {} = reader.get_{}()?;\n",
        replace_keyword(&length.name),
        length.data_type
    ));

    if optional {
        code.push_str("}\n");
    }
}

fn generate_deserialize_field(
    code: &mut String,
    field: &Field,
    enums: &[Enum],
    structs: &[Struct],
) {
    let optional = match field.optional {
        Some(true) => true,
        _ => false,
    };

    if optional {
        let name = match field.name {
            Some(ref name) => name,
            None => panic!("Field name is required for optional fields!"),
        };

        code.push_str(&format!(
            "        data.{} = if reader.remaining()? > 0 {{\n",
            replace_keyword(&name)
        ));
        code.push_str("            Some(");
        generate_inner_field_deserialize(code, field, enums, structs);
        code.push_str(")\n");
        code.push_str("        } else {\n");
        code.push_str("            None\n");
        code.push_str("        };\n");
    } else {
        if let Some(name) = &field.name {
            code.push_str(&format!("        data.{} = ", replace_keyword(&name)));
        }
        generate_inner_field_deserialize(code, field, enums, structs);
        code.push_str(";\n");
    }
}

fn generate_deserialize_array(
    code: &mut String,
    array: &Array,
    enums: &[Enum],
    structs: &[Struct],
) {
    let optional = match array.optional {
        Some(true) => true,
        _ => false,
    };

    if optional {
        code.push_str("        if reader.remaining()? > 0 {{\n");
        generate_inner_array_deserialize(code, array, enums, structs);
        code.push_str("        }\n");
    } else {
        generate_inner_array_deserialize(code, array, enums, structs);
    }
}

fn generate_deserialize_switch(
    code: &mut String,
    struct_name: &str,
    switch: &Switch,
    switch_enum: &Enum,
) {
    code.push_str(&format!(
        "        data.{}_data = match data.{} as i32 {{\n",
        replace_keyword(&switch.field),
        replace_keyword(&switch.field)
    ));
    for case in switch.cases.iter().filter(|c| c.elements.is_some()) {
        match case.value {
            Some(ref value) => {
                if let Some(EnumElement::Value(enum_value)) =
                    switch_enum.elements.iter().find(|e| match e {
                        EnumElement::Value(v) => v.name == *value,
                        _ => false,
                    })
                {
                    code.push_str(&format!(
                        "            {} => Some({}::{}({}::deserialize(reader)?)),\n",
                        enum_value.value,
                        get_field_type(&format!("{}_{}_data", struct_name, switch.field)),
                        replace_keyword(&value),
                        get_field_type(&format!(
                            "{}_{}_data_{}",
                            struct_name, switch.field, &value
                        ))
                    ));
                } else {
                    code.push_str(&format!(
                        "            {} => Some({}::{}({}::deserialize(reader)?)),\n",
                        value,
                        get_field_type(&format!("{}_{}_data", struct_name, switch.field)),
                        replace_keyword(&value),
                        get_field_type(&format!(
                            "{}_{}_data_{}",
                            struct_name, switch.field, &value
                        ))
                    ));
                }
            }
            None => match case.default {
                Some(true) => {
                    code.push_str(&format!(
                        "            _ => Some({}::Default({}::deserialize(reader)?)),\n",
                        get_field_type(&format!("{}_{}_data", struct_name, switch.field)),
                        get_field_type(&format!("{}_{}_data_default", struct_name, switch.field))
                    ));
                }
                _ => panic!("Unnamed switch case with default=false"),
            },
        }
    }

    if !switch.cases.iter().any(|c| match c.default {
        Some(true) => true,
        _ => false,
    }) {
        code.push_str(&format!("            _ => None,\n",));
    }
    code.push_str("        };\n");
}

fn generate_inner_field_deserialize(
    code: &mut String,
    field: &Field,
    enums: &[Enum],
    structs: &[Struct],
) {
    let (data_type, enum_data_type) = if field.data_type.contains(":") {
        field.data_type.split_once(":").unwrap()
    } else {
        (field.data_type.as_str(), "")
    };

    if let Some(ref protocol_enum) = enums.iter().find(|e| e.name == data_type) {
        // for the Foobar:short shit
        let enum_data_type = if enum_data_type.is_empty() {
            protocol_enum.data_type.to_string()
        } else {
            enum_data_type.to_string()
        };
        code.push_str(&format!(
            "{}::try_from(reader.get_{}()?)?",
            get_field_type(&data_type),
            enum_data_type,
        ));
    } else if let Some(_) = structs.iter().find(|s| s.name == data_type) {
        code.push_str(&format!("{}::deserialize(reader)?", field.data_type));
    } else {
        match data_type {
            "blob" => code.push_str("reader.get_bytes(reader.remaining()?)?"),
            "bool" => code.push_str(&format!(
                "reader.get_{}()? == 1",
                if enum_data_type.is_empty() {
                    "char"
                } else {
                    enum_data_type
                }
            )),
            _ => {
                code.push_str(&format!("reader.get_{}()?", data_type));
            }
        }
    }
}

fn generate_inner_array_deserialize(
    code: &mut String,
    array: &Array,
    enums: &[Enum],
    structs: &[Struct],
) {
    let delimited = match array.delimited {
        Some(true) => true,
        _ => false,
    };

    let need_guard = !array.trailing_delimiter && array.length.is_some();

    if let Some(length) = &array.length {
        code.push_str(&format!(
            "        for {} in 0..{} {{\n",
            if need_guard { "i" } else { "_" },
            length
        ));
    } else {
        code.push_str("        while reader.remaining()? > 0 {\n");
    }

    code.push_str(&format!("            data.{}.push(", array.name));
    generate_inner_field_deserialize(
        code,
        &Field {
            name: None,
            data_type: array.data_type.clone(),
            value: None,
            comment: None,
            padded: None,
            optional: None,
            length: None,
        },
        enums,
        structs,
    );
    code.push_str(");\n");

    if delimited {
        if need_guard {
            let length = match &array.length {
                Some(length) => length,
                None => panic!("Array length is required for non trailing- delimited arrays!"),
            };
            code.push_str(&format!("            if i + 1 < {} {{\n", length));
            code.push_str("                reader.next_chunk()?;\n");
            code.push_str("            }\n");
        } else {
            code.push_str("            reader.next_chunk()?;\n");
        }
    }

    code.push_str("        }\n");
}

fn write_struct_fields(code: &mut String, struct_name: &str, elements: &[StructElement]) {
    for element in elements {
        match element {
            StructElement::Field(field) => {
                if field.name.is_none() {
                    continue;
                }

                let optional = match field.optional {
                    Some(true) => true,
                    _ => false,
                };

                let comments = match &field.comment {
                    Some(comment) => get_comments(comment),
                    None => vec![],
                };

                for comment in &comments {
                    code.push_str(&format!("    /// {}\n", comment));
                }

                if optional {
                    code.push_str(&format!(
                        "    pub {}: Option<{}>,\n",
                        replace_keyword(&field.name.as_ref().unwrap()),
                        get_field_type(&field.data_type)
                    ));
                } else {
                    code.push_str(&format!(
                        "    pub {}: {},\n",
                        replace_keyword(&field.name.as_ref().unwrap()),
                        get_field_type(&field.data_type)
                    ));
                }
            }
            StructElement::Chunked(chunked) => {
                write_struct_fields(code, struct_name, &chunked.elements);
            }
            StructElement::Array(array) => {
                let comments = match &array.comment {
                    Some(comment) => get_comments(comment),
                    None => vec![],
                };

                for comment in &comments {
                    code.push_str(&format!("    /// {}\n", comment));
                }

                code.push_str(&format!(
                    "    pub {}: Vec<{}>,\n",
                    replace_keyword(&array.name),
                    get_field_type(&array.data_type)
                ));
            }
            StructElement::Switch(switch) => {
                code.push_str(&format!(
                    "    pub {}_data: Option<{}>,\n",
                    replace_keyword(&switch.field),
                    get_field_type(&format!("{}_{}_data", struct_name, switch.field))
                ));
            }
            _ => {}
        }
    }
}

fn get_field_type(data_type: &str) -> String {
    if data_type.contains(":") {
        return get_field_type(data_type.split(":").next().unwrap());
    }

    match data_type {
        "byte" => "u8".to_owned(),
        "char" => "i32".to_owned(),
        "short" => "i32".to_owned(),
        "three" => "i32".to_owned(),
        "int" => "i32".to_owned(),
        "bool" => "bool".to_owned(),
        "string" => "String".to_owned(),
        "encoded_string" => "String".to_owned(),
        "blob" => "Vec<u8>".to_owned(),
        _ => data_type.to_owned().to_case(convert_case::Case::Pascal),
    }
}

static PRIMITIVE_TYPES: [&str; 9] = [
    "byte",
    "char",
    "short",
    "three",
    "int",
    "bool",
    "string",
    "encoded_string",
    "blob",
];

fn get_imports(elements: &[StructElement], protocols: &[(Protocol, PathBuf)]) -> Vec<String> {
    let mut imports = vec![
        "use crate::data::{EoReader, EoReaderError, EoWriter, EoSerialize, EoSerializeError};"
            .to_owned(),
    ];

    let mut unique_types = HashSet::new();
    find_unique_types(elements, &mut unique_types);

    for primitive in &PRIMITIVE_TYPES {
        unique_types.remove(*primitive);
    }

    for unique_type in &unique_types {
        if let Some(protocol_path) = find_protocol_for_type(unique_type, protocols) {
            let use_path = match protocol_path.to_str().unwrap() {
                "eo-protocol/xml/protocol.xml" => "crate::protocol",
                "eo-protocol/xml/map/protocol.xml" => "crate::protocol::map",
                "eo-protocol/xml/pub/protocol.xml" => "crate::protocol::r#pub",
                "eo-protocol/xml/net/protocol.xml" => "crate::protocol::net",
                "eo-protocol/xml/net/client/protocol.xml" => "crate::protocol::net::client",
                "eo-protocol/xml/net/server/protocol.xml" => "crate::protocol::net::server",
                _ => panic!("Unknown protocol path: {}", protocol_path.to_string_lossy()),
            };

            imports.push(format!("use {}::{};", use_path, unique_type));
        }
    }

    imports
}

fn find_protocol_for_type<'a>(
    data_type: &str,
    protocols: &'a [(Protocol, PathBuf)],
) -> Option<&'a PathBuf> {
    for (protocol, path) in protocols {
        for element in &protocol.elements {
            match element {
                Element::Struct(protocol_struct) => {
                    if protocol_struct.name == data_type {
                        return Some(&path);
                    }
                }
                Element::Enum(protocol_enum) => {
                    if protocol_enum.name == data_type {
                        return Some(&path);
                    }
                }
                _ => {}
            }
        }
    }

    None
}

fn find_unique_types(elements: &[StructElement], unique_types: &mut HashSet<String>) {
    for element in elements {
        match element {
            StructElement::Field(field) => {
                if field.data_type.contains(":") {
                    unique_types.insert(field.data_type.split(":").next().unwrap().to_owned());
                } else {
                    unique_types.insert(field.data_type.clone());
                }
            }
            StructElement::Chunked(chunked) => {
                find_unique_types(&chunked.elements, unique_types);
            }
            StructElement::Array(array) => {
                unique_types.insert(array.data_type.clone());
            }
            StructElement::Switch(switch) => {
                for case in &switch.cases {
                    if let Some(elements) = &case.elements {
                        find_unique_types(elements, unique_types);
                    }
                }
            }
            _ => {}
        }
    }
}
fn get_comments(comment: &str) -> Vec<&str> {
    comment.split('\n').map(|c| c.trim()).collect::<Vec<&str>>()
}

fn append_doc_comments(code: &mut String, comments: Vec<&str>) {
    for comment in &comments {
        code.push_str(&format!("/// {}\n", comment));
    }
}

fn get_output_directory(base: &Path) -> PathBuf {
    Path::new("src/protocol").join(
        base.parent()
            .unwrap()
            .strip_prefix("eo-protocol/xml")
            .unwrap(),
    )
}

fn replace_keyword(word: &str) -> String {
    if word == "Self" {
        return "SELF".to_owned();
    }

    if word == "Ok" {
        return "OK".to_owned();
    }

    if word == "0" {
        return "Zero".to_owned();
    }

    if RUST_KEYWORDS.contains(&word) {
        format!("r#{}", word)
    } else {
        word.to_owned()
    }
}

fn parse_protocol_file(path: &std::path::Path) -> Result<Protocol, Box<dyn std::error::Error>> {
    let mut file = File::open(path)?;
    let mut xml = String::new();
    file.read_to_string(&mut xml)?;
    let protocol: Protocol = quick_xml::de::from_str(&xml)?;
    Ok(protocol)
}
