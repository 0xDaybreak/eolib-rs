use convert_case::Casing;
use glob::glob;
use serde::Deserialize;
use std::{
    collections::HashSet,
    fs::File,
    io::{Read, Write},
    path::{Path, PathBuf},
};

macro_rules! p {
    ($($tokens: tt)*) => {
        println!("cargo:warning={}", format!($($tokens)*))
    }
}

#[derive(Debug, Deserialize)]
struct Protocol {
    #[serde(rename = "$value", default)]
    pub elements: Vec<Element>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "lowercase")]
enum Element {
    Enum(Enum),
    Struct(Struct),
    Packet(Packet),
}

#[derive(Debug, Deserialize)]
struct Enum {
    #[serde(rename = "@name")]
    pub name: String,
    #[serde(rename = "@type")]
    pub data_type: String,
    #[serde(rename = "$value", default)]
    pub elements: Vec<EnumElement>,
}

#[derive(Debug, Deserialize)]
enum EnumElement {
    #[serde(rename = "comment")]
    Comment(String),
    #[serde(rename = "value")]
    Value(EnumValue),
}

#[derive(Debug, Deserialize)]
struct EnumValue {
    #[serde(rename = "@name")]
    pub name: String,
    #[serde(rename = "comment")]
    pub comment: Option<String>,
    #[serde(rename = "$text")]
    pub value: i32,
}

#[derive(Debug, Deserialize)]
struct Struct {
    #[serde(rename = "@name")]
    pub name: String,
    #[serde(rename = "$value", default)]
    pub elements: Vec<StructElement>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "lowercase")]
enum StructElement {
    Break,
    Chunked(Chunked),
    Comment(String),
    Dummy(Dummy),
    Field(Field),
    Array(Array),
    Length(Length),
    Switch(Switch),
}

#[derive(Debug, Deserialize)]
struct Chunked {
    #[serde(rename = "$value", default)]
    pub elements: Vec<StructElement>,
}

#[derive(Debug, Deserialize)]
struct Field {
    #[serde(rename = "@name")]
    pub name: Option<String>,
    #[serde(rename = "@type")]
    pub data_type: String,
    #[serde(rename = "$value", default)]
    pub value: Option<String>,
    pub comment: Option<String>,
    #[serde(rename = "padded")]
    pub padded: Option<bool>,
    #[serde(rename = "optional")]
    pub length: Option<String>,
}

fn default_as_true() -> bool {
    true
}

#[derive(Debug, Deserialize)]
struct Array {
    #[serde(rename = "@name")]
    pub name: String,
    #[serde(rename = "@type")]
    pub data_type: String,
    #[serde(rename = "@length")]
    pub length: Option<String>,
    #[serde(rename = "optional")]
    pub optional: Option<bool>,
    #[serde(rename = "delimited")]
    pub delimited: Option<bool>,
    #[serde(rename = "@trailing-delimiter")]
    #[serde(default = "default_as_true")]
    pub trailing_delimiter: bool,
    pub comment: Option<String>,
}

#[derive(Debug, Deserialize)]
struct Length {
    #[serde(rename = "@name")]
    pub name: String,
    #[serde(rename = "@type")]
    pub data_type: String,
    #[serde(rename = "@length")]
    pub optional: Option<bool>,
    #[serde(rename = "@offset")]
    pub offset: Option<i32>,
}

#[derive(Debug, Deserialize)]
struct Dummy {
    #[serde(rename = "@type")]
    pub data_type: String,
    #[serde(rename = "$value", default)]
    pub value: String,
}

#[derive(Debug, Deserialize)]
struct Switch {
    #[serde(rename = "@field")]
    pub field: String,
    #[serde(rename = "$value", default)]
    pub cases: Vec<Case>,
}

#[derive(Debug, Deserialize)]
#[serde(rename = "case")]
struct Case {
    #[serde(rename = "@default")]
    pub default: Option<bool>,
    #[serde(rename = "@value")]
    pub value: Option<String>,
    #[serde(rename = "$value", default)]
    pub elements: Option<Vec<StructElement>>,
}

#[derive(Debug, Deserialize)]
struct Packet {
    #[serde(rename = "@action")]
    pub action: String,
    #[serde(rename = "@family")]
    pub family: String,
    #[serde(rename = "$value", default)]
    pub elements: Vec<StructElement>,
}

static CODEGEN_WARNING: &str = r"// This file is automatically generated by build.rs
// Please do not edit it directly

";

static RUST_KEYWORDS: [&str; 52] = [
    "abstract", "alignof", "as", "become", "box", "break", "const", "continue", "crate", "do",
    "else", "enum", "extern", "false", "final", "fn", "for", "if", "impl", "in", "let", "loop",
    "macro", "match", "mod", "move", "mut", "offsetof", "override", "priv", "proc", "pub", "pure",
    "ref", "return", "Self", "self", "sizeof", "static", "struct", "super", "trait", "true",
    "type", "typeof", "unsafe", "unsized", "use", "virtual", "where", "while", "yield",
];

fn main() {
    println!("cargo:rerun-if-changed=eo-protocol/xml");

    let mut protocols = Vec::new();
    // find all protocol.xml files in the xml directory recursively
    for entry in glob("eo-protocol/xml/**/protocol.xml").expect("Failed to read glob pattern") {
        match entry {
            Ok(path) => match parse_protocol_file(&path) {
                Ok(protocol) => protocols.push((protocol, path.to_owned())),
                Err(e) => {
                    panic!(
                        "Failed to parse protocol file: {}. {}",
                        e,
                        path.to_string_lossy()
                    );
                }
            },
            Err(e) => {
                panic!("Failed to read protocol file: {}", e);
            }
        }
    }

    // clear the protocol directory
    if Path::new("src/protocol").exists() {
        std::fs::remove_dir_all("src/protocol").unwrap();
    }

    for (protocol, path) in &protocols {
        let output_dir = get_output_directory(path);
        std::fs::create_dir_all(&output_dir).unwrap();

        let mut mod_code = String::new();
        mod_code.push_str(CODEGEN_WARNING);

        for element in &protocol.elements {
            match element {
                Element::Enum(protocol_enum) => {
                    generate_enum_file(protocol_enum, &output_dir, &mut mod_code).unwrap()
                }
                Element::Struct(protocol_struct) => {
                    let imports = get_imports(&protocol_struct.elements, &protocols);
                    generate_struct_file(protocol_struct, imports, &output_dir, &mut mod_code)
                        .unwrap();
                }
                Element::Packet(packet) => {
                    let imports = get_imports(&packet.elements, &protocols);
                    generate_packet_file(packet, imports, &output_dir, &mut mod_code).unwrap();
                }
            }
        }

        let is_root = path.parent().unwrap() == Path::new("eo-protocol/xml");
        if is_root {
            // TODO: don't hard code this
            mod_code.push_str("pub mod map;\n");
            mod_code.push_str("pub mod net;\n");
            mod_code.push_str("pub mod r#pub;\n");
        }

        let is_net = path.parent().unwrap() == Path::new("eo-protocol/xml/net");
        if is_net {
            // TODO: don't hard code this
            mod_code.push_str("pub mod client;\n");
            mod_code.push_str("pub mod server;\n");
        }

        let mut mod_file = File::create(output_dir.join("mod.rs")).unwrap();
        mod_file.write_all(mod_code.as_bytes()).unwrap();
    }
}

fn generate_enum_file(
    protocol_enum: &Enum,
    path: &PathBuf,
    mod_code: &mut String,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut code = String::new();
    code.push_str(CODEGEN_WARNING);

    let comments = match protocol_enum
        .elements
        .iter()
        .find(|e| matches!(e, EnumElement::Comment(_)))
    {
        Some(EnumElement::Comment(comment)) => get_comments(comment),
        _ => vec![],
    };

    append_doc_comments(&mut code, comments);
    code.push_str(&format!("#[derive(Debug, PartialEq, Eq)]\n"));
    code.push_str(&format!("pub enum {} {{\n", protocol_enum.name));

    let variants: Vec<&EnumValue> = protocol_enum
        .elements
        .iter()
        .filter_map(|e| match e {
            EnumElement::Value(value) => Some(value),
            _ => None,
        })
        .collect();

    for variant in &variants {
        let comments = match &variant.comment {
            Some(comment) => get_comments(comment),
            None => vec![],
        };

        append_doc_comments(&mut code, comments);
        code.push_str(&format!("    {},\n", replace_keyword(&variant.name)));
    }
    code.push_str("}\n\n");

    code.push_str(&format!("impl {} {{\n", protocol_enum.name));
    code.push_str(&format!(
        "    pub fn from_i32(value: i32) -> Option<Self> {{\n"
    ));
    code.push_str(&format!("        match value {{\n"));

    for variant in &variants {
        code.push_str(&format!(
            "            {} => Some(Self::{}),\n",
            variant.value,
            replace_keyword(&variant.name)
        ));
    }

    code.push_str(&format!("            _ => None,\n"));
    code.push_str(&format!("        }}\n"));
    code.push_str(&format!("    }}\n\n"));
    code.push_str(&format!("    pub fn to_i32(&self) -> i32 {{\n"));
    code.push_str(&format!("        match self {{\n"));

    for variant in &variants {
        code.push_str(&format!(
            "            Self::{} => {},\n",
            replace_keyword(&variant.name),
            variant.value
        ));
    }

    code.push_str(&format!("        }}\n"));
    code.push_str(&format!("    }}\n"));
    code.push_str(&format!("}}\n\n"));

    code.push_str(&format!("impl Default for {} {{\n", protocol_enum.name));

    code.push_str(&format!("    fn default() -> Self {{\n"));
    code.push_str(&format!(
        "        Self::{}\n",
        replace_keyword(&variants[0].name)
    ));
    code.push_str(&format!("    }}\n"));
    code.push_str(&format!("}}\n"));

    code.push_str(CODEGEN_WARNING);

    let snake_name = protocol_enum.name.to_case(convert_case::Case::Snake);
    mod_code.push_str(&format!("mod {};\n", snake_name));
    mod_code.push_str(&format!("pub use {}::*;\n", snake_name));

    let mut file = File::create(path.join(format!(
        "{}.rs",
        protocol_enum.name.to_case(convert_case::Case::Snake)
    )))?;
    file.write_all(code.as_bytes())?;
    Ok(())
}

fn generate_struct_file(
    protocol_struct: &Struct,
    imports: Vec<String>,
    path: &PathBuf,
    mod_code: &mut String,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut code = String::new();
    code.push_str(CODEGEN_WARNING);

    for import in &imports {
        code.push_str(&format!("{}\n", import));
    }

    if imports.len() > 0 {
        code.push_str("\n");
    }

    write_struct(&protocol_struct.name, &protocol_struct.elements, &mut code);

    for switch in protocol_struct.elements.iter().filter_map(|e| match e {
        StructElement::Switch(switch) => Some(switch),
        _ => None,
    }) {
        let name = get_field_type(&format!("{}_{}_data", protocol_struct.name, switch.field));
        generate_switch_code(&name, &mut code, switch);
    }

    code.push_str(CODEGEN_WARNING);

    let snake_name = protocol_struct.name.to_case(convert_case::Case::Snake);
    let mut file = File::create(path.join(format!("{}.rs", snake_name)))?;

    file.write_all(code.as_bytes())?;

    mod_code.push_str(&format!("mod {};\n", snake_name));
    mod_code.push_str(&format!("pub use {}::*;\n", snake_name));

    Ok(())
}

fn generate_packet_file(
    packet: &Packet,
    imports: Vec<String>,
    path: &PathBuf,
    mod_code: &mut String,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut code = String::new();
    code.push_str(CODEGEN_WARNING);

    for import in &imports {
        code.push_str(&format!("{}\n", import));
    }

    if imports.len() > 0 {
        code.push_str("\n");
    }

    // either Server or Client
    let source = match path.to_str().unwrap() {
        "src/protocol/net/server" => "Server",
        "src/protocol/net/client" => "Client",
        _ => panic!("Unknown protocol path: {}", path.to_string_lossy()),
    };

    let name = format!("{}{}{}Packet", packet.family, packet.action, source);

    write_struct(&name, &packet.elements, &mut code);

    for switch in packet.elements.iter().filter_map(|e| match e {
        StructElement::Switch(switch) => Some(switch),
        _ => None,
    }) {
        let name = get_field_type(&format!("{}_{}_data", name, switch.field));
        generate_switch_code(&name, &mut code, switch);
    }

    // Assumes no nested chunked elements
    for chunked in packet.elements.iter().filter_map(|e| match e {
        StructElement::Chunked(chunked) => Some(chunked),
        _ => None,
    }) {
        for switch in chunked.elements.iter().filter_map(|e| match e {
            StructElement::Switch(switch) => Some(switch),
            _ => None,
        }) {
            let name = get_field_type(&format!("{}_{}_data", name, switch.field));
            generate_switch_code(&name, &mut code, switch);
        }
    }

    code.push_str(CODEGEN_WARNING);

    let snake_name = name.to_case(convert_case::Case::Snake);
    let mut file = File::create(path.join(format!("{}.rs", snake_name)))?;

    file.write_all(code.as_bytes())?;

    mod_code.push_str(&format!("mod {};\n", snake_name));
    mod_code.push_str(&format!("pub use {}::*;\n", snake_name));

    Ok(())
}

fn generate_switch_code(name: &str, code: &mut String, switch: &Switch) {
    code.push_str(&format!("#[derive(Debug, PartialEq, Eq)]\n"));
    code.push_str(&format!("pub enum {} {{\n", name));
    for case in switch.cases.iter().filter(|c| c.elements.is_some()) {
        match case.default {
            Some(true) => {
                code.push_str(&format!(
                    "    Default({}),\n",
                    get_field_type(&format!("{}_default", name)),
                ));
            }
            _ => {
                code.push_str(&format!(
                    "    {}({}),\n",
                    replace_keyword(&case.value.as_ref().unwrap()),
                    get_field_type(&format!("{}_{}", name, case.value.as_ref().unwrap()))
                ));
            }
        }
    }
    code.push_str("}\n\n");

    for case in switch.cases.iter().filter(|c| c.elements.is_some()) {
        let elements = case.elements.as_ref().unwrap();
        let name = match case.default {
            Some(true) => get_field_type(&format!("{}_default", name)),
            _ => get_field_type(&format!("{}_{}", name, case.value.as_ref().unwrap())),
        };

        write_struct(&name, elements, code);

        for switch in elements.iter().filter_map(|e| match e {
            StructElement::Switch(switch) => Some(switch),
            _ => None,
        }) {
            let name = get_field_type(&format!("{}_{}_data", name, switch.field));
            generate_switch_code(&name, code, switch);
        }
    }
}

fn write_struct(name: &str, elements: &[StructElement], code: &mut String) {
    let comments = match elements
        .iter()
        .find(|e| matches!(e, StructElement::Comment(_)))
    {
        Some(StructElement::Comment(comment)) => get_comments(comment),
        _ => vec![],
    };

    for comment in &comments {
        code.push_str(&format!("/// {}\n", comment));
    }

    let mut derives = vec!["Debug", "Default", "PartialEq", "Eq"];
    if name == "Coords" {
        derives.push("Clone");
        derives.push("Copy");
    }

    code.push_str(&format!("#[derive({})]\n", derives.join(", ")));
    code.push_str(&format!("pub struct {} {{\n", name));
    write_struct_fields(code, name, elements);
    code.push_str("}\n\n");

    code.push_str(&format!("impl {} {{\n", name));
    code.push_str("    pub fn new() -> Self {\n");
    code.push_str("        Self::default()\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");
}

fn write_struct_fields(code: &mut String, struct_name: &str, elements: &[StructElement]) {
    for element in elements {
        match element {
            StructElement::Field(field) => {
                if field.name.is_none() {
                    continue;
                }

                let comments = match &field.comment {
                    Some(comment) => get_comments(comment),
                    None => vec![],
                };

                for comment in &comments {
                    code.push_str(&format!("    /// {}\n", comment));
                }

                code.push_str(&format!(
                    "    pub {}: {},\n",
                    replace_keyword(&field.name.as_ref().unwrap()),
                    get_field_type(&field.data_type)
                ));
            }
            StructElement::Chunked(chunked) => {
                write_struct_fields(code, struct_name, &chunked.elements);
            }
            StructElement::Array(array) => {
                let comments = match &array.comment {
                    Some(comment) => get_comments(comment),
                    None => vec![],
                };

                for comment in &comments {
                    code.push_str(&format!("    /// {}\n", comment));
                }

                code.push_str(&format!(
                    "    pub {}: Vec<{}>,\n",
                    replace_keyword(&array.name),
                    get_field_type(&array.data_type)
                ));
            }
            StructElement::Switch(switch) => {
                code.push_str(&format!(
                    "    pub {}_data: Option<{}>,\n",
                    replace_keyword(&switch.field),
                    get_field_type(&format!("{}_{}_data", struct_name, switch.field))
                ));
            }
            _ => {}
        }
    }
}

fn get_field_type(data_type: &str) -> String {
    if data_type.contains(":") {
        return get_field_type(data_type.split(":").next().unwrap());
    }

    match data_type {
        "byte" => "i32".to_owned(),
        "char" => "i32".to_owned(),
        "short" => "i32".to_owned(),
        "three" => "i32".to_owned(),
        "int" => "i32".to_owned(),
        "bool" => "bool".to_owned(),
        "string" => "String".to_owned(),
        "encoded_string" => "String".to_owned(),
        "blob" => "Vec<u8>".to_owned(),
        _ => data_type.to_owned().to_case(convert_case::Case::Pascal),
    }
}

static PRIMITIVE_TYPES: [&str; 9] = [
    "byte",
    "char",
    "short",
    "three",
    "int",
    "bool",
    "string",
    "encoded_string",
    "blob",
];

fn get_imports(elements: &[StructElement], protocols: &[(Protocol, PathBuf)]) -> Vec<String> {
    let mut imports = Vec::new();

    let mut unique_types = HashSet::new();
    find_unique_types(elements, &mut unique_types);

    for primitive in &PRIMITIVE_TYPES {
        unique_types.remove(*primitive);
    }

    for unique_type in &unique_types {
        if let Some(protocol_path) = find_protocol_for_type(unique_type, protocols) {
            let use_path = match protocol_path.to_str().unwrap() {
                "eo-protocol/xml/protocol.xml" => "crate::protocol",
                "eo-protocol/xml/map/protocol.xml" => "crate::protocol::map",
                "eo-protocol/xml/pub/protocol.xml" => "crate::protocol::r#pub",
                "eo-protocol/xml/net/protocol.xml" => "crate::protocol::net",
                "eo-protocol/xml/net/client/protocol.xml" => "crate::protocol::net::client",
                "eo-protocol/xml/net/server/protocol.xml" => "crate::protocol::net::server",
                _ => panic!("Unknown protocol path: {}", protocol_path.to_string_lossy()),
            };

            imports.push(format!("use {}::{};", use_path, unique_type));
        }
    }

    imports
}

fn find_protocol_for_type<'a>(
    data_type: &str,
    protocols: &'a [(Protocol, PathBuf)],
) -> Option<&'a PathBuf> {
    for (protocol, path) in protocols {
        for element in &protocol.elements {
            match element {
                Element::Struct(protocol_struct) => {
                    if protocol_struct.name == data_type {
                        return Some(&path);
                    }
                }
                Element::Enum(protocol_enum) => {
                    if protocol_enum.name == data_type {
                        return Some(&path);
                    }
                }
                _ => {}
            }
        }
    }

    None
}

fn find_unique_types(elements: &[StructElement], unique_types: &mut HashSet<String>) {
    for element in elements {
        match element {
            StructElement::Field(field) => {
                if field.data_type.contains(":") {
                    unique_types.insert(field.data_type.split(":").next().unwrap().to_owned());
                } else {
                    unique_types.insert(field.data_type.clone());
                }
            }
            StructElement::Chunked(chunked) => {
                find_unique_types(&chunked.elements, unique_types);
            }
            StructElement::Array(array) => {
                unique_types.insert(array.data_type.clone());
            }
            StructElement::Switch(switch) => {
                for case in &switch.cases {
                    if let Some(elements) = &case.elements {
                        find_unique_types(elements, unique_types);
                    }
                }
            }
            _ => {}
        }
    }
}
fn get_comments(comment: &str) -> Vec<&str> {
    comment.split('\n').map(|c| c.trim()).collect::<Vec<&str>>()
}

fn append_doc_comments(code: &mut String, comments: Vec<&str>) {
    for comment in &comments {
        code.push_str(&format!("/// {}\n", comment));
    }
}

fn get_output_directory(base: &Path) -> PathBuf {
    Path::new("src/protocol").join(
        base.parent()
            .unwrap()
            .strip_prefix("eo-protocol/xml")
            .unwrap(),
    )
}

fn replace_keyword(word: &str) -> String {
    if word == "Self" {
        return "SELF".to_owned();
    }

    if word == "0" {
        return "Zero".to_owned();
    }

    if RUST_KEYWORDS.contains(&word) {
        format!("r#{}", word)
    } else {
        word.to_owned()
    }
}

fn parse_protocol_file(path: &std::path::Path) -> Result<Protocol, Box<dyn std::error::Error>> {
    let mut file = File::open(path)?;
    let mut xml = String::new();
    file.read_to_string(&mut xml)?;
    let protocol: Protocol = quick_xml::de::from_str(&xml)?;
    Ok(protocol)
}
